/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "types.h"
#include "RtosInclude.h"

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

void FunctionTarea1 (void);
void FunctionTarea2 (void);
void FunctionTarea3 (void);
void FunctionTarea4 (void);

T_TaskTCB Tarea1;
T_TaskTCB Tarea2;
T_TaskTCB Tarea3;
T_TaskTCB Tarea4;

UInt32 StackTarea1[256];
UInt32 StackTarea2[256];
UInt32 StackTarea3[256];
UInt32 StackTarea4[300];

void FunctionStackOverflow();
//T_QueueHandler RoundRobinScheduler;

//T_QueueElement Elemento1;
//T_QueueElement Elemento2;
//T_QueueElement Elemento3;
//T_QueueElement Elemento4;

int main (void)
{
	/*  * Data;
	Queue_Init(&TestQueue);

	Queue_Enqueue(&RoundRobinScheduler, &Tarea1.QueueElement, &Tarea1);
	T_TaskTCB_Ptr Task;
	Queue_Dequeue(&RoundRobinScheduler, &Task);

	Port_InitTickTimer();*/
	RTOS_Init();
	Task_Create(&Tarea1, 1, "Tarea1", 4, (UInt32 *) StackTarea1, 256, FunctionTarea1);
	Task_Create(&Tarea2, 2, "Tarea2", 3, (UInt32 *) StackTarea2, 256, FunctionTarea2);
	Task_Create(&Tarea3, 3, "Tarea3", 2, (UInt32 *) StackTarea3, 256, FunctionTarea3);
	Task_Create(&Tarea4, 4, "Tarea4", 1, (UInt32 *) StackTarea4, 300, FunctionTarea4);

	RCC_APB2ENR |= RCC_APB2ENR_IOPC_EN;
	GPIOC_CRH |= GPIOC_CRH_MODE13; //| GPIOC_CRH_CNF13;


//Para configurar y utilizar el puerto B, puedes hacer lo siguiente:

	// Habilitar el reloj para el puerto GPIOB
	RCC_APB2ENR |= RCC_APB2ENR_IOPB_EN;
	GPIOB_CRL |= GPIOB_CRL_MODE5;

	GPIOB_CRL |= GPIOB_CRL_MODE1;

	RTOS_Start();
	/* Loop Forever */
	for( ; ; );
}

void FunctionTarea1(void)
{
	for(; ; )
	{
		//Define Pins
		#define BEEPER_Pin GPIO_PIN_3
		#define BEEPER_GPIO_Port GPIOA
		#define CONTROL_A_Pin GPIO_PIN_0
		#define CONTROL_A_GPIO_Port GPIOA
		#define CONTROL_B_Pin GPIO_PIN_1
		#define CONTROL_B_GPIO_Port GPIOA

		//Define Visuals
		//char ssd1306_WriteString(char* str, FontDef Font, SSD1306_COLOR color)
		#define FONT_SIZE 2
		#define SCREEN_WIDTH 127
		#define SCREEN_HEIGHT 63
		#define PADDLE_WIDTH 4
		#define PADDLE_HEIGHT 10
		#define PADDLE_PADDING 10
		#define BALL_SIZE 3
		#define SCORE_PADDING 10

		#define EFFECT_SPEED 0.5
		#define MIN_Y_SPEED 0.5
		#define MAX_Y_SPEED 2

		/* Private variables ---------------------------------------------------------*/
		ADC_HandleTypeDef hadc1;
		ADC_HandleTypeDef hadc2;

		I2C_HandleTypeDef hi2c2;

		TIM_HandleTypeDef htim2;

		TIM_HandleTypeDef htim2;
		//Define Variables
		//ssd1306_HandleTypeDef = hOled;


		int paddleLocationA = 0;
		int paddleLocationB = 0;

		float ballX = SCREEN_WIDTH / 2;
		float ballY = SCREEN_HEIGHT / 2;
		float ballSpeedX = 2;
		float ballSpeedY = 1;

		int lastPaddleLocationA = 0;
		int lastPaddleLocationB = 0;

		int scoreA = 0;
		int scoreB = 0;

		#define BEEPER_TIM_INSTANCE  TIM2
		//#define BEEPER_TIM_CHANNEL   TIM_CHANNEL_1
		#define BEEPER_TIM_CLK_ENABLE()  __HAL_RCC_TIM2_CLK_ENABLE()
		// Function Declarations
		void SystemClock_Config(void);
		//static void MX_GPIO_Init(void);
		//static void MX_SPI1_Init(void);
		static void MX_ADC1_Init(void);
		static void MX_ADC2_Init(void);
		void MX_USART1_UART_Init(void);
		void MX_I2C1_Init(void);

		void calculateMovement();
		void draw();
		void addEffect(int paddleSpeed);
		void soundBounce(void);
		void soundPoint(void);
		void splash();
		void setup();

		void soundStart(void);
		void initBeeper(void);

		void centerPrint(char *text, int y, int size);

		int loop(void) {
		    // STM32 Initialization Code (generated by STM32CubeIDE)
		    HAL_Init();
		    SystemClock_Config();
		   // MX_GPIO_Init();
		    //MX_SPI1_Init();
		    MX_USART1_UART_Init();
		    MX_I2C1_Init();
		    MX_ADC1_Init();
		    MX_ADC2_Init();
		    // OLED Initialization
		   // hOled.hspi = &hspi1;  // hspi1 is the SPI handle from STM32CubeIDE
		    //hOled.i2c = &hi2c1;  // hi2c1 is the I2C handle from STM32CubeIDE
		    ssd1306_Init();



		    while (1) {
		        calculateMovement();
		        draw();
		        HAL_Delay(50);  // Adjust the delay as needed
		    }
		}
		static void MX_ADC1_Init(void)
		{

		  /* USER CODE BEGIN ADC1_Init 0 */

		  /* USER CODE END ADC1_Init 0 */

		  ADC_ChannelConfTypeDef sConfig = {0};

		  /* USER CODE BEGIN ADC1_Init 1 */

		  /* USER CODE END ADC1_Init 1 */

		  /** Common config
		  */
		  hadc1.Instance = ADC1;
		  hadc1.Init.ScanConvMode = ADC_SCAN_DISABLE;
		  hadc1.Init.ContinuousConvMode = DISABLE;
		  hadc1.Init.DiscontinuousConvMode = DISABLE;
		  hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;
		  hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
		  hadc1.Init.NbrOfConversion = 1;
		  if (HAL_ADC_Init(&hadc1) != HAL_OK)
		  {
		    //Error_Handler();
		  }

		  /** Configure Regular Channel
		  */
		  sConfig.Channel = ADC_CHANNEL_0;
		  sConfig.Rank = ADC_REGULAR_RANK_1;
		  sConfig.SamplingTime = ADC_SAMPLETIME_1CYCLE_5;
		  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
		  {
		    //Error_Handler();
		  }
		  /* USER CODE BEGIN ADC1_Init 2 */

		  /* USER CODE END ADC1_Init 2 */

		}

		/**
		  * @brief ADC2 Initialization Function
		  * @param None
		  * @retval None
		  */
		static void MX_ADC2_Init(void)
		{

		  /* USER CODE BEGIN ADC2_Init 0 */

		  /* USER CODE END ADC2_Init 0 */

		  ADC_ChannelConfTypeDef sConfig = {0};

		  /* USER CODE BEGIN ADC2_Init 1 */

		  /* USER CODE END ADC2_Init 1 */

		  /** Common config
		  */
		  hadc2.Instance = ADC2;
		  hadc2.Init.ScanConvMode = ADC_SCAN_DISABLE;
		  hadc2.Init.ContinuousConvMode = DISABLE;
		  hadc2.Init.DiscontinuousConvMode = DISABLE;
		  hadc2.Init.ExternalTrigConv = ADC_SOFTWARE_START;
		  hadc2.Init.DataAlign = ADC_DATAALIGN_RIGHT;
		  hadc2.Init.NbrOfConversion = 1;
		  if (HAL_ADC_Init(&hadc2) != HAL_OK)
		  {
		    //Error_Handler();
		  }

		  /** Configure Regular Channel
		  */
		  sConfig.Channel = ADC_CHANNEL_1;
		  sConfig.Rank = ADC_REGULAR_RANK_1;
		  sConfig.SamplingTime = ADC_SAMPLETIME_1CYCLE_5;
		  if (HAL_ADC_ConfigChannel(&hadc2, &sConfig) != HAL_OK)
		  {
		    //Error_Handler();
		  }
		  /* USER CODE BEGIN ADC2_Init 2 */

		  /* USER CODE END ADC2_Init 2 */

		}

		/**
		  * @brief I2C2 Initialization Function
		  * @param None
		  * @retval None
		  */
		void setup() {
		   // SSD1306_Clear(&hOled);

		    splash();

		    ssd1306_Fill(White);
		    //SSD1306_SetTextSize(&hOled, FONT_SIZE);
		    ssd1306_WriteString("hola",Font_6x8,White);
		   // SSD1306_Clear(&hOled);
		}

		void splash() {
		   // SSD1306_Clear(&hOled);

			ssd1306_Fill(White);
		    //SSD1306_SetTextSize(&hOled, FONT_SIZE);
			//char ssd1306_WriteString(char* str, FontDef Font, SSD1306_COLOR color)
			ssd1306_WriteString("PONG", Font_6x8, White);
		    //ssd1306_WriteString((char* ("PONG")), (FontDef Font_6x8),White);
			ssd1306_WriteString("By Diego Gomez", Font_6x8,White);
		    //ssd1306_WriteString("By Diego Gómez", FONT_SIZE,White);
		    ssd1306_WriteString("and juan Valencia", Font_6x8,White);
		    ssd1306_WriteString("SOTR", Font_6x8,White);

		    ssd1306_DrawRectangle( 0, SCREEN_HEIGHT - 10, SCREEN_WIDTH, 10, White);
		    ssd1306_Fill(Black);
		    //char ssd1306_WriteChar(char ch, FontDef Font, SSD1306_COLOR color)
		    //ssd1306_WriteChar( "Move paddle to start!", SCREEN_HEIGHT - 9, White);
		    ssd1306_WriteChar( *"Move paddle to start!", Font_16x24, White);

		    ssd1306_UpdateScreen();

		    int controlA;
		    int controlB;

		    // Assuming CONTROL_A and CONTROL_B are analog pins
		    // Adjust the GPIO_PIN_x and GPIOx accordingly
		    controlA = HAL_ADC_GetValue(&hadc1);  // hadc1 is the ADC handle from STM32CubeIDE
		    controlB = HAL_ADC_GetValue(&hadc2);  // hadc2 is another ADC handle if needed

		    while (HAL_ADC_GetValue(&hadc1) - controlA + HAL_ADC_GetValue(&hadc2) - controlB < 10) {
		        // show as long as the total absolute change of
		        // both potentiometers is smaller than 10
		    }

		    // Assuming soundStart() is a function you've defined for sound generation
		    // Adjust the GPIO_PIN_x and GPIOx accordingly
		     soundStart();
		}

		void calculateMovement(void) {
		    // Assuming CONTROL_A and CONTROL_B are analog pins
		    // Adjust the GPIO_PIN_x and GPIOx accordingly
		    int controlA = HAL_ADC_GetValue(&hadc1);  // hadc1 is the ADC handle from STM32CubeIDE
		    int controlB = HAL_ADC_GetValue(&hadc2);  // hadc2 is another ADC handle if needed

		    paddleLocationA = map(controlA, 0, 4095, 0, SCREEN_HEIGHT - PADDLE_HEIGHT);
		    paddleLocationB = map(controlB, 0, 4095, 0, SCREEN_HEIGHT - PADDLE_HEIGHT);

		    int paddleSpeedA = paddleLocationA - lastPaddleLocationA;
		    int paddleSpeedB = paddleLocationB - lastPaddleLocationB;

		    ballX += ballSpeedX;
		    ballY += ballSpeedY;

		    // Bounce from top and bottom
		    if (ballY >= SCREEN_HEIGHT - BALL_SIZE || ballY <= 0) {
		        ballSpeedY *= -1;
		        soundBounce();
		    }

		    // Bounce from paddle A
		    if (ballX >= PADDLE_PADDING && ballX <= PADDLE_PADDING + BALL_SIZE && ballSpeedX < 0) {
		        if (ballY > paddleLocationA - BALL_SIZE && ballY < paddleLocationA + PADDLE_HEIGHT) {
		            soundBounce();
		            ballSpeedX *= -1;

		            addEffect(paddleSpeedA);
		        }
		    }

		    // Bounce from paddle B
		    if (ballX >= SCREEN_WIDTH - PADDLE_WIDTH - PADDLE_PADDING - BALL_SIZE && ballX <= SCREEN_WIDTH - PADDLE_PADDING - BALL_SIZE && ballSpeedX > 0) {
		        if (ballY > paddleLocationB - BALL_SIZE && ballY < paddleLocationB + PADDLE_HEIGHT) {
		            soundBounce();
		            ballSpeedX *= -1;

		            addEffect(paddleSpeedB);
		        }
		    }

		    // Score points if the ball hits the wall behind the paddle
		    if (ballX >= SCREEN_WIDTH - BALL_SIZE || ballX <= 0) {
		        if (ballSpeedX > 0) {
		            scoreA++;
		            ballX = SCREEN_WIDTH / 4;
		        }
		        if (ballSpeedX < 0) {
		            scoreB++;
		            ballX = SCREEN_WIDTH / 4 * 3;
		        }

		        soundPoint();
		    }

		    // Set last paddle locations
		    lastPaddleLocationA = paddleLocationA;
		    lastPaddleLocationB = paddleLocationB;
		}

		void draw(void) {
		    //SSD1306_Clear(&hOled);

		    // Draw paddle A
			ssd1306_DrawRectangle( PADDLE_PADDING, paddleLocationA, PADDLE_WIDTH, PADDLE_HEIGHT, White);

		    // Draw paddle B
			ssd1306_DrawRectangle( SCREEN_WIDTH - PADDLE_WIDTH - PADDLE_PADDING, paddleLocationB, PADDLE_WIDTH, PADDLE_HEIGHT, White);

		    // Draw center line
		    for (int i = 0; i < SCREEN_HEIGHT; i += 4) {
		    	ssd1306_DrawPixel(SCREEN_WIDTH / 2, i, White);
		    }

		    // Draw ball
		    ssd1306_FillCircle( ballX, ballY, BALL_SIZE, White);

		    // Print scores
		    int scoreAWidth = 5 * FONT_SIZE;

		    if (scoreA > 9) scoreAWidth += 6 * FONT_SIZE;
		    if (scoreA > 99) scoreAWidth += 6 * FONT_SIZE;
		    if (scoreA > 999) scoreAWidth += 6 * FONT_SIZE;
		    if (scoreA > 9999) scoreAWidth += 6 * FONT_SIZE;

		    ssd1306_Fill(White);
		    //SSD1306_SetTextSize(&hOled, FONT_SIZE);
		    ssd1306_SetCursor( SCREEN_WIDTH / 2 - SCORE_PADDING - scoreAWidth, 0);
		    //ssd1306_WriteString( itoa(scoreA, buffer, 10)); //el marcador falta por corregir

		    ssd1306_SetCursor( SCREEN_WIDTH / 2 + SCORE_PADDING + 1, 0);  // +1 because of dotted line
		   //ssd1306_WriteString( itoa(scoreB, buffer, 10)); //el marcador falta por corregir

		    ssd1306_UpdateScreen();
		}

		void addEffect(int paddleSpeed)
		{
		    float oldBallSpeedY = ballSpeedY;

		    // Añadir efecto a la pelota cuando la paleta se está moviendo mientras rebota.
		    // Por cada píxel de movimiento de la paleta, agregar o sustraer EFFECT_SPEED a la velocidad de la pelota.
		    for (int effect = 0; effect < abs(paddleSpeed); effect++) {
		        if (paddleSpeed > 0) {
		            ballSpeedY += EFFECT_SPEED;
		        } else {
		            ballSpeedY -= EFFECT_SPEED;
		        }
		    }

		    // Limitar a la velocidad mínima
		    if (ballSpeedY < MIN_Y_SPEED && ballSpeedY > -MIN_Y_SPEED) {
		        if (ballSpeedY > 0) ballSpeedY = MIN_Y_SPEED;
		        if (ballSpeedY < 0) ballSpeedY = -MIN_Y_SPEED;
		        if (ballSpeedY == 0) ballSpeedY = oldBallSpeedY;
		    }

		    // Limitar a la velocidad máxima
		    if (ballSpeedY > MAX_Y_SPEED) ballSpeedY = MAX_Y_SPEED;
		    if (ballSpeedY < -MAX_Y_SPEED) ballSpeedY = -MAX_Y_SPEED;
		}

		void soundStart(void) {
		    HAL_TIM_PWM_Start(&htim2, BEEPER_TIM_INSTANCE);

		    __HAL_TIM_SET_COMPARE(&htim2, BEEPER_TIM_INSTANCE, 250);
		    HAL_Delay(100);

		    __HAL_TIM_SET_COMPARE(&htim2, BEEPER_TIM_INSTANCE, 500);
		    HAL_Delay(100);

		    __HAL_TIM_SET_COMPARE(&htim2, BEEPER_TIM_INSTANCE, 1000);
		    HAL_Delay(100);

		    HAL_TIM_PWM_Stop(&htim2, BEEPER_TIM_INSTANCE);
		}

		void initBeeper(void) {
		    BEEPER_TIM_CLK_ENABLE();

		    TIM_OC_InitTypeDef sConfigOC;

		    htim2.Instance = BEEPER_TIM_INSTANCE;
		    htim2.Init.Prescaler = 72 - 1;  // Adjust prescaler as needed
		    htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
		    htim2.Init.Period = 1000;  // Adjust period as needed
		    htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;

		    HAL_TIM_PWM_Init(&htim2);

		    sConfigOC.OCMode = TIM_OCMODE_PWM1;
		    sConfigOC.Pulse = 0;
		    sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
		    sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;

		    HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, BEEPER_TIM_INSTANCE);
		}

		void soundBounce(void) {
		    HAL_TIM_PWM_Start(&htim2, BEEPER_TIM_INSTANCE);
		    __HAL_TIM_SET_COMPARE(&htim2, BEEPER_TIM_INSTANCE, 500);
		    HAL_Delay(50);
		    HAL_TIM_PWM_Stop(&htim2, BEEPER_TIM_INSTANCE);
		}

		void soundPoint(void) {
		    HAL_TIM_PWM_Start(&htim2, BEEPER_TIM_INSTANCE);
		    __HAL_TIM_SET_COMPARE(&htim2, BEEPER_TIM_INSTANCE, 150);
		    HAL_Delay(150);
		    HAL_TIM_PWM_Stop(&htim2, BEEPER_TIM_INSTANCE);
		}

		void centerPrint(char *text, int y, int size) {
		    // Ajusta según la función real de la biblioteca SSD1306 para STM32
		    //SSD1306_SetTextSize(size);
		    ssd1306_SetCursor(SCREEN_WIDTH/2 - (SSD1306_GetStringWidth(text)*size)/2, y);
		    //SSD1306_Print(text);
		}
		// Resto del código, funciones calculateMovement(), draw(), addEffect(), soundBounce(), soundPoint() sin cambios...

	}
}
void FunctionTarea2(void)
{
	for(; ; )
	{
		GPIOB_BSRR |= GPIOB_BSRR_BS1; // Establecer el bit 1 del registro de set/reset
		Task_Sleep(250);
		//GPIOC_BSRR |= GPIOC_BSRR_BR13;
		GPIOB_BSRR |= GPIOB_BSRR_BR1; // Establecer el bit 1 del registro de reset
		Task_Sleep(250);
	}
}
void FunctionTarea3(void)
{
	for(; ; )
	{
		GPIOC_BSRR |= GPIOC_BSRR_BS13;
		Task_Sleep(100);
		GPIOC_BSRR |= GPIOC_BSRR_BR13;
		Task_Sleep(100);
	}
}
void FunctionTarea4(void)
{
	for(; ; )
	{
		//GPIOC_BSRR |= GPIOC_BSRR_BS13;
		GPIOB_BSRR |= GPIOB_BSRR_BS5; // Establecer el bit 5 del registro de set/reset
		Task_Sleep(500);
		//GPIOC_BSRR |= GPIOC_BSRR_BR13;
		GPIOB_BSRR |= GPIOB_BSRR_BR5; // Establecer el bit 5 del registro de reset
		Task_Sleep(500);
		//FunctionStackOverflow();
	}
}
/*void TaskControlLED(void *pvParameters) {
    while (1) {
        // Leer el estado de la entrada
        int inputState = HAL_GPIO_ReadPin(GPIOx, GPIO_PIN);

        // Control del LED basado en la entrada
        if (inputState == INPUT_CONDITION) {
            // Encender el LED
            HAL_GPIO_WritePin(LED_GPIO_Port, LED_PIN, GPIO_PIN_SET);
        } else {
            // Apagar el LED
            HAL_GPIO_WritePin(LED_GPIO_Port, LED_PIN, GPIO_PIN_RESET);
        }

        // Agregar un retardo o utilizar vTaskDelay() si es necesario
        vTaskDelay(pdMS_TO_TICKS(100)); // Ejemplo de retardo de 100 ms
    }
}*/
void FunctionStackOverflow()
{
	unsigned long Count;
	unsigned long Vec [240];
    for (Count = 0; Count < 240; Count++)
    {
    	Vec[Count] = 0;
    }
}

